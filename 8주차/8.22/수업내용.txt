유니온 파인드

Union - Find

그룹맺는 것 => union 동작
같은 그룹인지 확인하는 방법 => find

==> 같은 그룹인지 아닌지 빨리 확인하는 방법

그룹을 맺는 행동을 한다 => 그러다 특정 데이터가 같은 그룹인지 확인한다. 
==> 이걸 빨리 해주는 자료구조 = 유니온 파인드


같은 그룹인지 아닌지 확인방법
 if (find('C') == find('B')) <== 같은 그룹

union('A','B'); // 그룹 맺기 앞쪽이 보스
union('A','C');


=========================
int main() {
   union('A', 'B');
   union('A', 'C');
   //이제 A랑 B랑 같은그룹인가?
   if (find('A') == find('B')) cout << "같은그룹"
   else cout << "다른그룹"
}

==========================

union('A','B') ===>  B의 보스가 A의 보스 밑으로 들어감

===================================================


Union - Find 구조를 진행시 항상 "대표가 기준"

대표를 찾는 방법 : Find()

=========================================
그래프 저장 방법 : 트리구조
각 노드는 부모가 딱 1개 -> DAT 활용

parent[node]번호 = 해당 node의 부모

1. Disjoint set <- 분리집합 (겹쳐져 있지 않고 완전히 분리된 집합)
을 다룰때 유니온 파인드 사용

2. 집합단위로 관리할때 유용

=========================================

지금 구조사에서의 단점 : *  Find가 느림
		      * 합치는 과정만 있음



=========================================

<2번째 유형>
## 분리시켜서 사용하는 방법

* 분리 <-> 합병
	완전히 반대 개념


=> 반대로 아래서부터 위로 올라가면서 이어준다.

================================

Union-Find <- disjoin set분리집랍 단위 데이터를 관리하는데 용이
1. 집합 단위로 데이터를 관리해서 빠르게 답변해야 하는 경우
2. *분리되는 과정* <- 역산해서 합병으로 진행하는 경우
	

========================================
* MST (Min Spanning Tree)

최소 비용으로 연결할때

       cost가 낮은 엣지부터 	연결(하나의 그룹화) 
(=> sort / PQ 아무거나 사용)      (Union-Find)

단, 이미 같은 그룹인 엣지의 순서면 무시
			 (Union-Find <= Find)




































