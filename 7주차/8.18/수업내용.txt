#Bitmasking

1byte <- 8bit
용량 , 크기

1bit : 0 or 1 2진수 1자리

int<- 4byte <- 32bit 
	// int의 최대크기 : 21억4천만---

bit 맨앞자리 : 부호 // 0이면 양수, 1이면 음수

* 비트연산자

bit단위로 and or

#############
& -> && : and

| -> || : or 

^ : Xor  
        => 두 수에서 다른 비트는 1 같은 비트는 0;
        => (toggle)0을 1로 1을 0으로 뒤집어줌

<< : a<<b 
       = a를 b만큼 bit를 옮겨준다. / a가 2의b제곱만큼 곱해진값
       = bit를 왼쪽으로 한칸 밀때마다 값이 2배가됨
       ex) 2*2*2*2*2  == <<5

>>: a>>b 
       = a를 b만큼 bit를 옮겨준다.  / a가 2의b제곱만큼 나눠준값

       =이동시 범위를 벗어나는 비트는 지워버림 


*조사식에서 2진수로 보는 방법
=> 변수이름.b

############

#언제 사용 하는가
      
    &  => 특정 bit를 추출할때 사용 , 
         => 특정 비트를 0으로 만들고 싶을때사용  ==> 알고싶은 부분만 0 나머지는 1로 찾기 ==> 나머지 부분이 1인지 아닌지 정확하게 모르기 때문에
         => -1.b = 0b111111111111111... 

    
    |    => 특정 bit를 1로 만들어주고 싶을때 사용

    ^  => toggle기능
	=> 특정위치가 0 또는 1인 수를 만들 수 있음 => &으로 0을 찾기위해 만드는 수를 만들때 특정 위치를 잡기 편함
	=> 변수의 1이 있는 위치를 0으로 바꿔줌
	=> 비트가 0인부분은 원본데이터와 같은 수가 나오고 1인 부분은 반전되서 나옴 (특정 비트를 반전)
	=> 두번 반복하면 원래대로 돌아옴 ==> a^b^c^c^b
	=> 교환법칙 성립

	
	## 1의 개수 찾기
	int a = 4865132
	int tmp = a;
	int cnt = 0;
	while(tmp)
	{
	    if(tmp & 1) cnt++; // 1의 자리에 bit가 존재 하는가?
	
	    tmp = tmp>>1
	}

	## 연속해서 1이 있는 경우가 몇가지 인지?
	int a = 4865132
	int tmp = a;
	int cnt = 0;
	while(tmp)
	{
	    if((tmp & 0b11) ==  0b11) cnt++; // 끝에 연달아서 11이 있는가?
	
	    tmp = tmp>>1
	}


###########################################################

* Dynamicprogramming

 -> 재계산을 방지하여 빠르게 원하는 값까지 계산

1. 같은 규칙으로 계산해 나가야 한다.
	(큰 문제를 해결하는 방법과 작은 문제를 해결하는 방법이 같다.)
	==> 점화식으로 표현 가능한지

2. * 한 번 계산한 결과가 바뀌지 않는가* 
	=> 한 번 계산한 결과가 바뀌면 안된다.


* DP를 해결하는 방법

모든게 그래프 형태라고 생각하면 편함

1. 상황을 설명할 수 있는 요인,변인을 생각 == > 답을 바꿀수 있는 모든 변인, 요인
	
2. 배열 설정 dp[] 
	=> 변인 요인이 1개면 1차원, 2개면 2차원, 3개면 3차원 배열 생성
	ex>집 인테리어 ==> dp[집][인테리어]

3. 규칙 찾기 ->  어떤 규칙으로 개선해 나갈지 
	=> now라는 상황이 있을때,
	=> now라는 상황을 만들 수 있는 바로 직전 상황만 고려

################################################################
DP : 기존 데이터를 사용해서 현재 데이터를 만드는 방식 
	ex) 피보나치 수열

DP 푸는 방법
- Bottom Up : 밑에서부터 올라오는 방식 
	=> 배열 사용
	=> 배열 채우기

- Top Down : 반대로 맨 뒤에서부터 문제 해결방법에 접근하는 방식
	=> 수학 귀납식 증명 방법
	=> f(n)을 f(n-1)로 구할 수 있다면 모든 경우를 구할 수 있다.

	1)탑다운으로 짜보기(메모이제이션 없이)
	2) 작은값에 값이 잘 나오는구나 확인
	3) 메모이제이션 적용


현재 비트연산을 배우는 이유
 - DP에 비트연산을 해서 이득을 보는 경우가 있음


#####################################################################

다이나믹 프로그래밍 구현 방법

1. Bottom-up : 배열탐색 

2. Top-down : dfs+DP
		*주의*now라는 점에서 진행하는 방법에 따라 결과가 바뀌면 안됨
		
		DFS에서 DP로 변환하는 과정
		1)끝에서부터 계산 결과를 받아서 now를 계산
		2)dp배열에 계산결과를 저장하고 활용

두 방식 모두 알아야함

#####################################################################

 탑다운 방식 -> 개구리 문제같이 앞으로 얼마나 점수를 얻을 수 있을까의 방식은 dfs사용
	    -> 다양햔 경로를 탐색하기 때문에

#####################################################################
삼성역량평가 A형 -> DP는 안나옴

